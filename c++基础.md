#### 智能指针 
1. shared_ptr 允许多个指针指向同一个对象
	+ 每一个shared_ptr都有一个关联的计数器，通常称为引用计数，当拷贝一个share_ptr时，计数器就会增加，当计数器为0时shared_ptr调用指向对象的析构函数将对象销毁。
	+ 分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回一个指向此对象的shared_ptr
	  ``` shared_ptr<int> p3=make_shared<int>(42);  //指向一个值为42的int的shared_ptr ```
2. weak_ptr 也是一个引用计数型指针，但是它不增加对象的引用次数，即弱引用。但是它知道对象是否还活着
3. unique_ptr 独占所指向的对象



#### explicit
#### g++执行的四个过程
+ 预处理：条件编译，头文件包含，宏替换处理，生成.i文件
+ 编译：将预处理后的文件转换成汇编语言，生成.S文件
+ 汇编：汇编变为目标代码（机器代码）生成.o的文件
+ 链接：连接目标代码，生成可执行程序

#### 变量声明和定义的区别
+ 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间
+ 相同声明变量可以在多处声明（外部变量exertn），但只能在一处定义。
#### extern
extern可以置于变量或者函数前，以表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。另外，extern也可用来进行链接指定

## 编程基础

#### strlen和sizeof区别
+ sizeof 是运算符，并不是函数，结果在编译时得到；strlen是字符处理的库函数，结果在运行中获得
+ sizeof参数可以是任何数据的类型或者数据，计算的是对象使用的最大字节数；strlen的参数只能是字符指针且结尾是‘\0’的字符串，计算字符串的实际长度 

#### 结构体内存对齐问题
+ 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同
+ 未特殊说明，按结构体中size最大的成员对齐（若有double成员），按8字节对齐
+ 对齐原因：
	+ 平台移植性好：不是所有的硬件平台都能访问任意地址上的数据，某些硬件平台只能只在某些地址访问某些特定类型的数据，否则抛出硬件异常，或者遇到未对齐的边界直接就不进行读取数据了
	2.cpu处理率高：对齐限制简化了形成处理器和内存系统之间接口的硬件设计。假设处理器总是从内存读取8个字节，则地址必须是8的倍数，否则可能需指向执行两次内存访问。p189


#### static作用是什么？在c和c++中有什么区别
+ static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非寒素调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。
+ c++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，时多有类实例共同拥有。
+ static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。
+ 未初始化时，static变量默认为0；


#### C++和C的区别

+ 设计思想上：C++是面向对象的语言，而C是面向过程的结构化编程语言。
+ 语法上：
	+ C++具有封装、继承、多态三种特性
	+ C++相比C，增加许多类型安全的功能比如强制类型转换
	+ C++支持范式编程，比如模板类、函数模板等

#### 结构体和类的区别（struct和class）
+ 结构体的默认限定符是public 而类是private

#### malloc和new区别
+ malloc和free是标准库函数，支持覆盖；new和delete是运算符，并支持重载
+ malloc仅仅分配内存空间，free仅仅回收内存空间，不具备调用构造函数和析构函数的功能，new和delete除了分匹配回收功能外，还会调用构造函数和析构函数。
+ malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

#### 指针和引用的区别
+ 引用只是别名，不占用具体存储空间，只有声明并没有定义；指针是具体变量，需要占用存储空间
+ 引用在声明时必须初始化为另一变量；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时在指向具体变量
+ 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量的引用）；指针变量可以重新指向别的变量。
+ 不存在指向空指针的引用，必须有具体实体；但是存在指向空指针的指针。

#### 宏定义和函数有何区别
+ 宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来快；函数调用在运行时需要跳转到具体调用的函数
+ 宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。
+ 宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
+ 宏函数不要在最后加分号

#### 什么是常引用
+ 常引用可以理解为常量指针
+ 常引用下原变量值不会被改引用修改
+ 变量的值可以通过原名修改
+ 常引用通常作为只读变量别名或是形参传递

#### 常量指针和指针常量的区别
+ 常量指针，是指一个指向常量的指针如int const *p或const int *p。
+ 指针常量，是指指针本身是常量，即不可改变指向如int *const p。

#### 野指针是什么
+ 指向内存被释放的内存或者没有访问权限的内存的指针，不是指向null的指针
+ 产生原因即解决方法
	+ 指针变量未及时初始化->定义指针变量及时初始化，要么置空。
	+ 指针free或delete之后没有即使置空->释放操作后立即置空

#### 堆和栈的区别
+ 申请方式不同
	+ 栈是由系统自动分配
	+ 堆是由程序员手动分配
+ 申请大小限制不同
	+ 栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。
	+ 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。
+ 申请效率不同
	+ 栈由系统分配，速度快，不会有碎片
	+ 由程序员分配，速度慢，会有碎片

#### delete和delete[]的区别
+ delete只会调用一次析构
+ delete[]会调用数组中每个元素的析构函数。